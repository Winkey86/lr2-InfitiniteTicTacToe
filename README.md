# TTT4Infinite — Крестики‑нолики 4‑в‑ряд на бесконечном поле (C++17 + SFML)




**Функционал**
- Бесконечное поле (хранение только занятых клеток в `unordered_map<Coord,Cell>`).
- Победа при 4 в ряд по 4 направлениям.
- Три алгоритма ИИ (переключаются клавишами **1/2/3**):
  1) Greedy (жадный 1-ply)
  - Идея. Посчитать лишь «один ход вперёд»:если можно выиграть прямо сейчас — сделать этот ход; иначе, если соперник может выиграть своим  следующим ходом — заблокировать; иначе — выбрать ход с лучшей статической оценкой позиции (эвристика).
  2) Negamax + Alpha-Beta
  - Идея. Классический минимакс в форме Negamax (симметрия ролей упрощает Minimax) с отсечениями alpha-beta: мы ищем ход, максимизирующий нашу оценку, предполагая, что соперник дальше тоже играет наилучшим образом. Глубина d = «сколько полуходов просматриваем вперёд». 
  - alpha — лучшая найденная оценка для текущего игрока (нижняя граница).
  - beta — лучшая оценка, которую может гарантировать противник (верхняя граница).
  - Если в какой-то момент выполняется alpha >= beta,дальше ветки просматривать нет смысла — результат всё равно туда не пойдёт.
  3) MCTS (Monte-Carlo Tree Search) — это метод, который не строит всё дерево ходов (как minimax),а много раз случайно “играет партию до конца” (плейауты) и считает статистику выигрышей. Здесь упрощённая версия:

Пусть сейчас ход **ноликов**.  
Кандидатные ходы: `A`, `B`, `C`.

1. Для каждого хода делаем **копию поля** и ставим туда нолик.
2. Для каждой такой позиции выполняем `N` случайных партий (**плейаутов**):
   - оба игрока ставят **случайные ходы**,  
   - игра продолжается, пока кто-то не победит или не будет ничьи.
3. Для каждого исходного хода считаем статистику побед ноликов.

Например, при `N = 100`:

| Ход | Побед ноликов | Итераций | Доля побед |
|-----|---------------|----------|------------|
| A   | 30            | 100      | 30%        |
| B   | 52            | 100      | 52%        |
| C   | 48            | 100      | 48%        |

Алгоритм выбирает ход с **наибольшим процентом побед** в плейаутах.  
В данном примере это ход **`B`**.
- Zobrist-хеш (Zobrist hashing) — это способ уникально кодировать игровое состояние (например, в шахматах, крестиках-ноликах, ГО и т.п.) в виде одного 64-битного числа, чтобы быстро хранить и сравнивать позиции в хеш-таблице
- Доска — это unordered_map<Coord, Cell>: храним только занятые координаты, поэтому поле фактически бесконечно.

**Сборка (Windows, без vcpkg)**

1. Установите SFML (например, в `C:\libs\SFML-2.6.1`).
2. Генерация проекта VS 2022 (x64):
   ```powershell
   cmake -S . -B build -G "Visual Studio 17 2022" -A x64 `
     -DCMAKE_FIND_PACKAGE_PREFER_CONFIG=ON `
     -DSFML_DIR="C:\libs\SFML-2.6.1\lib\cmake\SFML" `
     -DBUILD_SFML=ON
   cmake --build build --config Release
   Copy-Item "C:\libs\SFML-2.6.1\bin\*.dll" -Destination "build\Release" -Force
   ```
3. Запуск:
   - Консоль: `build\Release\ttt4_console.exe`
   - SFML UI: `build\Release\ttt4_sfml.exe`


**Суть алгоритмов и управление**
- *Алгоритм 1 (Greedy 1‑ply)* — проверяет «выиграй сейчас», затем «заблокируй противника», иначе выбирает ход с лучшей статической оценкой (`Board::evaluate`).
- *Алгоритм 2 (Alpha‑Beta)* — классический Negamax с отсечениями на фиксированной глубине (**[ / ]** — изменить глубину). Порядок ходов: выигрыши → блоки → эвристическая сортировка.
- *Алгоритм 3 (ID)* — итеративное углубление до заданной максимальной глубины с Transposition Table. Обновляет лучший ход после каждой пройденной глубины; безопасен по времени.
  
**Эвристика оценки**
- Для каждой «лучи» (4 направления) считаются длина непрерывной цепочки и «открытые концы». Таблица очков:
  - 4 и более — `+1e6`
  - «тройка» с двумя концами — `+1e4`, с одним — `+3e3`
  - «двойка» с двумя — `+500`, с одним — `+120`
  - «одиночка» с двумя — `+10`
  - Оценка позиции = очки O − очки X.

**Тесты**
- Включите `-DBUILD_TESTS=ON`, цель `ttt4_tests` содержит базовые проверки.

**Замечания**
- На бесконечной доске ничьи формально нет; ограничение кандидатов радиусом существенно ускоряет поиск.
- Код кроссплатформенный (Linux/macOS требуют установленного SFML 2.5+).

Удачи!
